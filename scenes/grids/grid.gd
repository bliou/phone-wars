class_name Grid
extends Node2D

signal cell_short_tap(cell_position: Vector2i)
signal cell_long_press(cell_position: Vector2i)
signal cell_long_press_release(cell_position: Vector2i)

var query_manager: QueryManager
var terrain_manager: TerrainManager

var building_cells := {}  # Vector2i → building

var cell_size: Vector2 = Vector2(32, 32)  # default cell size

func setup(input_manager: InputManager, p_query_manager: QueryManager, p_terrain_manager) -> void:
	terrain_manager = p_terrain_manager
	query_manager = p_query_manager

	# subscribe to input events
	input_manager.short_tap.connect(on_short_tap)
	input_manager.long_press.connect(on_long_press)
	input_manager.long_press_release.connect(on_long_press_release)


func on_short_tap(world_pos: Vector2) -> void:
	var cell_pos: Vector2i = terrain_manager.world_to_cell(world_pos)
	cell_short_tap.emit(cell_pos)


func on_long_press(world_pos: Vector2) -> void:
	var cell_pos: Vector2i = terrain_manager.world_to_cell(world_pos)
	cell_long_press.emit(cell_pos)


func on_long_press_release(world_pos: Vector2) -> void:
	var cell_pos: Vector2i = terrain_manager.world_to_cell(world_pos)
	cell_long_press_release.emit(cell_pos)


func get_world_position_from_cell(cell_position: Vector2i) -> Vector2:
	return terrain_manager.cell_to_world(cell_position)


# Return a dictionary of all the reachable cells with:
# key: cell position in grid space
# value: cost to move into this cell
func get_reachable_cells(unit: Unit) -> Dictionary:
	var start: Vector2i = unit.grid_pos
	var frontier := [{ "cell": start, "cost": 0.0 }]
	var visited := { start: 0.0 }

	while frontier.size() > 0:
		frontier.sort_custom(func(a, b): return a.cost < b.cost)
		var current = frontier.pop_front()
		var cell: Vector2i = current.cell
		var cost: float = current.cost

		for neighbor in get_neighbors(cell):
			# cannot walk on this terrain
			var terrain: TerrainType.Values = terrain_manager.get_terrain_type(neighbor)
			var step_cost = unit.get_terrain_cost(terrain)
			if step_cost == INF:
				continue

			# not enough movement points left
			var new_cost = cost + step_cost
			if new_cost > unit.unit_profile.movement_points:
				continue

			# cannot walk through enemy units
			var enemy_unit: Unit = query_manager.get_unit_at(neighbor)
			if enemy_unit != null and not enemy_unit.team.is_same_team(unit.team):
				continue

			if not visited.has(neighbor) or new_cost < visited[neighbor]:
				visited[neighbor] = new_cost
				frontier.append({ "cell": neighbor, "cost": new_cost })

	return visited  # cell → cost


# Helpers method to get all the neighbors of a cell even if disabled in AStar
func get_neighbors(cell: Vector2i) -> Array[Vector2i]:
	const DIRS : Array[Vector2i] = [
		Vector2i.LEFT,
		Vector2i.RIGHT,
		Vector2i.UP,
		Vector2i.DOWN
	]
	var neighbors: Array[Vector2i] = []

	for d in DIRS:
		neighbors.append(cell + d)

	return neighbors


func get_cells_in_manhattan_range(
	center: Vector2i,
	min_range: int,
	max_range: int
) -> Array[Vector2i]:
	var cells: Array[Vector2i] = []

	for dx in range(-max_range, max_range + 1):
		var dy_limit = max_range - abs(dx)
		for dy in range(-dy_limit, dy_limit + 1):
			var dist = abs(dx) + abs(dy)
			if dist < min_range:
				continue

			cells.append(center + Vector2i(dx, dy))

	return cells
